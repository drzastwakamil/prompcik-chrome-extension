# Migration Guide: Plain JavaScript to Vue.js

This document explains the refactoring from vanilla JavaScript DOM manipulation to Vue.js components.

## Overview

The Chrome extension has been completely refactored to use Vue.js 3 with Vite as the build tool. This brings significant improvements in code organization, maintainability, and developer experience.

## What Changed

### Before: Plain JavaScript (1256 lines in content.js)
- Manual DOM manipulation with `createElement()`, `appendChild()`, etc.
- Inline styles via `element.style.*`
- innerHTML strings for complex UI
- Global state management with plain objects
- Manual event listener management

### After: Vue.js Components
- Declarative templates
- Reactive state management
- Scoped component styles
- Computed properties for derived state
- Automatic event binding with @click, @mouseenter, etc.

## File Structure Changes

### Old Structure
```
chrome_extension/
├── content.js           (1256 lines of DOM manipulation)
├── popup.js             (Simple script)
├── popup.html           (With inline styles)
├── background.js        (Service worker)
├── styles.css           (Animations)
└── manifest.json
```

### New Structure
```
chrome_extension/
├── src/
│   ├── components/
│   │   ├── FactCheckBubble.vue
│   │   ├── FactCheckSidePanel.vue
│   │   ├── FloatingToolbar.vue
│   │   └── NotificationToast.vue
│   ├── content/
│   │   └── main.js
│   └── popup/
│       ├── Popup.vue
│       └── main.js
├── dist/                (Generated by build)
├── scripts/
│   └── post-build.js
├── background.js
├── popup.html
├── vite.config.js
├── package.json
└── manifest.json
```

## Component Breakdown

### 1. FactCheckBubble.vue
**Before (lines 598-902 in content.js):**
```javascript
function createBubble(anchorElOrRect, options = {}) {
  const container = document.createElement('div');
  container.className = 'fnf-attached-overlay-container';
  // ... 300+ lines of DOM manipulation
  overlay.innerHTML = `<div>...</div>`;
  // ... more DOM manipulation
}
```

**After:**
```vue
<template>
  <div class="fnf-attached-overlay-container">
    <div v-if="state === 'loading'">...</div>
    <div v-else-if="state === 'result'">...</div>
  </div>
</template>

<script>
export default {
  data() {
    return { state: 'loading' }
  },
  computed: {
    // Derived state automatically updates
  }
}
</script>
```

**Benefits:**
- State changes automatically update UI
- No manual DOM manipulation
- Cleaner separation of concerns
- Type-safe props and events

### 2. FactCheckSidePanel.vue
**Before (lines 906-1131 in content.js):**
```javascript
function showFactCheckSidePanel(result, text) {
  const panel = document.createElement('div');
  panel.innerHTML = `
    <div class="fnf-panel-header">...</div>
    <!-- 200+ lines of HTML string -->
  `;
  document.body.appendChild(panel);
  // Manual event binding
  closeBtn.addEventListener('click', hideFactCheckSidePanel);
}
```

**After:**
```vue
<template>
  <teleport to="body">
    <div v-if="visible" class="fnf-fact-check-panel">
      <div class="fnf-panel-header">{{ title }}</div>
      <!-- Clean template syntax -->
    </div>
  </teleport>
</template>

<script>
export default {
  props: ['visible', 'result', 'text'],
  computed: {
    title() { return this.isFakeNews ? 'Alert!' : 'Unknown Status' }
  }
}
</script>
```

**Benefits:**
- Teleport API for portal-style rendering
- Reactive visibility
- Computed properties for dynamic content
- Automatic cleanup on unmount

### 3. FloatingToolbar.vue
**Before (lines 1182-1254 in content.js):**
```javascript
function createToolbarOverlay() {
  const toolbar = document.createElement('div');
  toolbar.style.position = 'fixed';
  // ... 50+ lines of style assignments
  factBtn.addEventListener('click', () => {
    startFactCheckSelectionMode();
  });
  makeDraggable(toolbar);
}
```

**After:**
```vue
<template>
  <div :style="toolbarStyle" @mousedown="startDrag">
    <button @click="onFactCheck">🛡️ Fact-check</button>
  </div>
</template>

<script>
export default {
  data() {
    return { position: { top: 20, right: 20 }, isDragging: false }
  },
  computed: {
    toolbarStyle() {
      return { position: 'fixed', top: `${this.position.top}px`, ... }
    }
  }
}
</script>
```

**Benefits:**
- Drag state managed reactively
- Computed styles update automatically
- Cleaner event handling

### 4. NotificationToast.vue
**Before (lines 492-517 in content.js):**
```javascript
const notification = document.createElement('div');
notification.style.cssText = `
  position: fixed;
  top: 20px;
  // ... 15+ lines of inline styles
`;
notification.textContent = '⚠️ Cannot fact-check: No text found';
document.body.appendChild(notification);
setTimeout(() => {
  notification.style.animation = 'fadeOut 0.3s ease';
  setTimeout(() => notification.remove(), 300);
}, 3000);
```

**After:**
```vue
<template>
  <teleport to="body">
    <div v-if="visible" :class="typeClass">{{ message }}</div>
  </teleport>
</template>

<script>
export default {
  props: ['message', 'type', 'duration'],
  mounted() {
    setTimeout(() => this.visible = false, this.duration);
  }
}
</script>
```

**Benefits:**
- Self-contained lifecycle management
- Reusable with different types
- Automatic cleanup

## State Management

### Before: Global Objects
```javascript
let __fcSelection = {
  active: false,
  highlightBox: null,
  prevCursor: '',
  hoverEl: null,
  persistentHighlight: null,
  scrollTimeout: null,
};
```

### After: Component Data & Props
```javascript
// In Vue component
data() {
  return {
    state: 'loading',
    loadingMessage: 'Fact checking…'
  }
}
```

## Event Handling

### Before: Manual Event Listeners
```javascript
closeBtn.addEventListener('click', () => {
  overlay.remove();
});
```

### After: Vue Event Binding
```vue
<button @click="onClose">×</button>
```

## Styling

### Before: Inline Styles
```javascript
overlay.style.background = 'linear-gradient(135deg, #6366f1 0%, #4f46e5 100%)';
overlay.style.color = '#ffffff';
overlay.style.padding = '20px 22px';
// ... 20+ more lines
```

### After: Scoped Styles
```vue
<style scoped>
.fnf-attached-overlay {
  background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);
  color: #ffffff;
  padding: 20px 22px;
}
</style>
```

## Build Process

### Development Workflow

1. **Install dependencies:**
   ```bash
   npm install
   ```

2. **Build for development (watch mode):**
   ```bash
   npm run dev
   ```

3. **Build for production:**
   ```bash
   npm run build
   ```

4. **Load extension:**
   - Open `chrome://extensions/`
   - Enable "Developer mode"
   - Click "Load unpacked"
   - Select the `dist/` directory

### What Happens During Build

1. Vite compiles Vue components to JavaScript
2. Bundles dependencies (Vue runtime)
3. Optimizes and minifies code
4. Generates source maps
5. Post-build script fixes paths for Chrome extension compatibility

## Key Benefits

### 1. Code Reduction
- **Before:** 1256 lines in content.js
- **After:** ~400 lines in main.js + ~600 lines across 4 Vue components
- **Result:** Easier to read and maintain

### 2. Separation of Concerns
- Templates separate from logic
- Styles scoped to components
- Props/events for component communication

### 3. Reactivity
- State changes automatically update UI
- No manual DOM synchronization
- Computed properties for derived state

### 4. Developer Experience
- Better IDE support (autocomplete, type checking)
- Component hot reload during development
- Vue DevTools for debugging (in popup, not content scripts)

### 5. Maintainability
- Each component is self-contained
- Easy to test components in isolation
- Clear component boundaries

## Migration Checklist

If you need to add new features:

- [ ] Create a new `.vue` component file
- [ ] Define template, script, and styles
- [ ] Import and use in main.js or other components
- [ ] Build and test

## Common Patterns

### Creating a Component Instance
```javascript
const app = createApp(ComponentName, {
  // Props
  propName: value,
  // Event handlers
  onEventName: (data) => { /* handle */ }
});
app.mount(container);
```

### Cleaning Up
```javascript
app.unmount();
container.remove();
```

### Passing Data Between Components
Use props down, events up:
```javascript
// Parent
onLearnMore: ({ result, text }) => {
  showSidePanel(result, text);
}

// Child component emits
this.$emit('learn-more', { result, text });
```

## Backwards Compatibility

The extension maintains the same user-facing functionality:
- Same UI/UX
- Same API calls to backend
- Same Chrome extension APIs
- Same fact-checking workflow

Only the internal implementation has changed.

## Testing

After building:
1. Load the extension in Chrome
2. Navigate to any webpage
3. Click the floating toolbar's "Fact-check" button
4. Select an element on the page
5. Verify the bubble appears with loading state
6. Verify the result displays correctly
7. Click "Learn More" to test the side panel
8. Test the popup

## Troubleshooting

### Build fails
- Check Node.js version (use v16+)
- Delete `node_modules` and `dist`, reinstall: `npm install`

### Extension doesn't load
- Make sure you're loading `dist/` folder, not root
- Check Chrome console for errors
- Verify manifest.json is in dist/

### UI doesn't appear
- Check browser console for Vue errors
- Verify content script is injected
- Check for CSP violations

### Changes not visible
- Rebuild: `npm run build`
- Reload extension in Chrome
- Refresh the webpage

## Future Enhancements

With Vue.js, it's now easier to:
- Add TypeScript for better type safety
- Implement Vuex/Pinia for complex state management
- Create a testing suite with Vitest
- Add more interactive features
- Create reusable component libraries
- Implement animations with Vue transitions

## Conclusion

This refactoring dramatically improves code quality while maintaining full functionality. The component-based architecture makes the extension easier to maintain, extend, and debug.
